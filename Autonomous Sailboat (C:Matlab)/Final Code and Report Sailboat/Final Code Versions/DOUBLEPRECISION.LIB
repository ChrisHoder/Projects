/* START LIBRARY DESCRIPTION *********************************************
Double precision (IEEE 754) floating point library

DESCRIPTION: This library provides for double precision floating point math

The data is stored in little endian format.


Some time tests on the library are as follows:
Add/subtract--215uS with same power of two, 240uS for worst case.
Multiply--275uS regardless of power of 2
Divide--1250uS
Square root--2270uS
log2--7060uS



END DESCRIPTION **********************************************************/
/*** BeginHeader */

// #define DEMO_VERSION


#ifdef DEMO_VERSION
   #ifndef RAM_COMPILE
      #ifdef _RAM_
         #define RAM_COMPILE 1
      #else
         #define RAM_COMPILE 0
      #endif
   #endif
   #if !RAM_COMPILE
      #fatal "Double Precision demo version will only run in RAM"
   #endif
#endif

/*** EndHeader */


/*** BeginHeader */
typedef struct  {
   char Bytes[8];
} _double;
const _double dpZero={0,0,0,0,0,0,0,0};
const _double dpNegZero={0,0,0,0,0,0,0,128};
const _double dpPosInfinity={0,0,0,0,0,0,0xF0, 0x7F};
const _double dpNegInfinity={0,0,0,0,0,0,0xF0, 0xFF};
const _double dpNaN={0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff};
const _double dpOne={0,0,0,0,0,0,0xF0, 0x3F};
const _double dpTwo={0,0,0,0,0,0,0x00, 0x40};
const _double dpNegOne={0,0,0,0,0,0,0xF0, 0xBF};
const _double dpPiDiv2={0xF8, 0x26, 0x44, 0x54, 0xFB, 0x21, 0xF9, 0x3F};
const _double dpPi={0xF8, 0x26, 0x44, 0x54, 0xFB, 0x21, 0x09, 0x40};
const _double dpTen={0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x40};

/*** EndHeader */

/* START FUNCTION DESCRIPTION ********************************************
dpMakeNum                                            <DoublePrecision.LIB>

SYNTAX: _double dpMakeNum(long Num1, long Num2);

DESCRIPTION: Takes the bytes from two long numbers and creates a double precision
             number.  The values for Num1 and Num2 are created by the PC program
             whenever a constant is used.  This is *not* at all equivalent to a
             long to double conversion--this should only be used if the source code
             line is generated by the PC program.
END DESCRIPTION **********************************************************/

/*** BeginHeader dpMakeNum*/
_double dpMakeNum(long Num1, long Num2);

/*** EndHeader */
_double dpMakeNum(long Num1, long Num2) {
   auto _double ReturnValue;
   #asm

      ld hl, (sp+@sp+Num2);
      ld (sp+@sp+ReturnValue), hl
      ld hl, (sp+@sp+Num2+2)
      ld (sp+@sp+ReturnValue+2), hl
      ld hl, (sp+@sp+Num1)
      ld (sp+@sp+ReturnValue+4), hl
      ld hl, (sp+@sp+Num1+2)
      ld (sp+@sp+ReturnValue+6), hl

   #endasm
   return ReturnValue;
}


/* START FUNCTION DESCRIPTION ********************************************
dpFloat2Double                                      <DoublePrecision.LIB>

SYNTAX: _double dpFloat2Double(float Num);

DESCRIPTION: Converts an IEEE 754 single precision number to a double precision
             number
END DESCRIPTION **********************************************************/

/*** BeginHeader dpFloat2Double*/
_double dpFloat2Double(float Num);
/*** EndHeader */

_double dpFloat2Double(float Num) {
   auto _double Return;		// Weak on how to return a structure in assembly--may be optimized someday when I learn better
   if (Num==0) return dpZero;
   #asm
c 	Num;					// Put NUM back in BCDE
      ld hl, Return+@sp+7  // Someday, this will directly go to the structure.
      add hl, sp

      ld iy, hl

      ld (hl), b
      dec hl
      ld (hl), c
      dec hl
      ld (hl), d
      dec hl
      ld (hl), e

      // Rotate everything by three positions to allow room for 11 exponent bits in double precision instead of 8
      ld b, 3
loop1:
      ld hl, iy
      rr (hl)
      dec hl
      rr (hl)
      dec hl
      rr (hl)
      dec hl
      rr (hl)
      dec hl
      rr (hl)
      djnz loop1

      // Now, move the sign bit back where it belongs and adjust the bias on the exponent
      ld hl, iy
      ld a, (hl)
      and a, 0x1F 			// Clear out the high bits that were shifted in with RR--clear then all at once instead of clearing the carry in the loop above
      ld b, a
      sla a
      sla a
      sla a
      and a, 0x80   			// Get the carry bit back where it belongs
      or a, b
      and a, 0x8F				// Clear out the extra exponent bits in preparation for addition below
      add a, 0x38				// Convert bias from 127 to 1023
      ld (hl), a
      // Clear out the final bits
      dec hl
      dec hl
      dec hl
      dec hl
      ld a, (hl)
      and a, 0xE0
      ld (hl), a
      dec hl
      ld a, 0
      ld (hl), a
      dec hl
      ld (hl), a
      dec hl
      ld (hl), a
	#endasm
	return Return;
}




/* START FUNCTION DESCRIPTION ********************************************
dpDouble2Float                                       <DoublePrecision.LIB>

SYNTAX: float dpDouble2Float(_double Num)

DESCRIPTION: Converts a 64 bit IEEE 754 number into a 32 bit IEEE number

PARAMETER:

RETURN VALUE:

END DESCRIPTION **********************************************************/





/*** BeginHeader dpDouble2Float*/
float dpDouble2Float(_double Num);
/*** EndHeader */

xmem nouseix float dpDouble2Float(_double Num) {
   #asm
      ld iy, Num+@sp
      add iy, sp
      ld a, (iy+7)			// Preserve the original sign
      ld c, a
      and a, 0x7F			// Clear out the sign bit

      // Do some checking on exponent range
      cp 0x38
      jr nc, NoUnderflow
      // Return the signed zero if an underflow occurs.
      ld a, c
      and 0x80
      ld b, a
      ld c, 0
      ld d, 0
      ld e, 0
      lret

NoUnderflow:
      cp 0x48
      jr c, NoOverflow
      // Return the appropriate infinity on overflow
      ld a, c
      or a, 0x7F
      ld b, a
      ld c, 0x80
      ld d, 0
      ld e, 0
      lret
NoOverflow:			// If we got here, the number is within range and we can convert it
      add a, -0x38			// Subtract 0x38, this prevents the necessity of clearing the carry.
      ld (iy+7), a			// OK to modify NUM--it passed by stack, and original won't be hurt
      ld b, 3
Loop:
		ld hl, (iy+0) $ add hl, hl $ ld (iy+0), hl
      ld hl, (iy+2) $ adc hl, hl $ ld (iy+2), hl
      ld hl, (iy+4) $ adc hl, hl $ ld (iy+4), hl
      ld hl, (iy+6) $ adc hl, hl $ ld (iy+6), hl
      djnz Loop

      // Rounding is skipped on the lsb because my mantissa might be all ones and I don't feel to split it apart

      // Put the sign bit back
      ld a, (iy+7)
      and 0x7f
      ld b, a
      ld a, c
      and 0x80
      add a, b
      ld b, a
      ld c, (iy+6)
      ld d, (iy+5)
      ld e, (iy+4)
      lret
	#endasm
}


/*** BeginHeader _dpUnpack*/
void _dpUnpack(_double *NumIn, char *NumOut);
/*** EndHeader */

nodebug void _dpUnpack(_double *NumIn, char *NumOut) {
   // The character buffer is 11 bytes.  The first byte if for rounding, and zeroed out.
   // The next six bytes are copied from the double precision number--remember that all bytes are
   // backwards to maintain compatibility with Visual Basic.
   // The next byte contains the 4 remaining bits of the mantissa with the leading bit (hidden in the IEEE representation) put into bit position 5
   // The next two bytes are the exponent with the bias removed (signed integer)
   // The next byte is zero for positive, 128 for negative.
   #ifdef DEMO_VERSION
      if (((RdPortI(STACKSEG)>0x40) && (RdPortI(STACKSEG)<0xF0)) ||
          ((RdPortI(DATASEG)>0x40)  && (RdPortI(DATASEG )<0xF0))
         ) {
           printf("How did you manage to get this program to compile to flash when it is a demo version???");
           for(;;);
      }
	#endif

   #asm xmemok
   	push ix						// Save this sacred register--all others can be used by a function.
      ld iy, (SP+@sp+NumIn+2)	// +2 is because of the push ix
      ld ix, (SP+@sp+NumOut+2)

      ld a, 0
      ld (ix), a
      ld a, (iy)
      ld (ix+1), a
      ld a, (iy+1)
      ld (ix+2), a
      ld a, (iy+2)
      ld (ix+3), a
      ld a, (iy+3)
      ld (ix+4), a
      ld a, (iy+4)
      ld (ix+5), a
      ld a, (iy+5)
      ld (ix+6), a

      // Now, our six bytes are copied over
      ld a, (iy+6)
      ld b, a
      and a, 0x0F
      or a, 0x10
      ld (ix+7), a			// Store the last byte of the mantissa
      ld a, (iy+7)
      ld c, a

      // hl contains the exponent plus a few extras
      ld h, a
      ld l, b

      rr hl  		// Shift the exponent to the right position
      rr hl
      rr hl
      rr hl
      ld de, 0x07FF    // Remove extra bits
      and hl, de
      ld de, -1023     // Remove the bias
      add hl, de
      ld (ix+8), l
      ld (ix+9), h
      ld a, c          // Store the sign bit
      and 0x80
      ld (ix+10), a
      pop ix
   #endasm
}


/*** BeginHeader _dpPack*/
_double _dpPack(char *Unpacked);

/*** EndHeader */

_double _dpPack(char *Unpacked) {
   auto int Exponent;
   auto char Sign;
   auto _double Return;

   // First, normalize the answer, then some range checking
   #asm
      push ix
      ld ix, (SP+@sp+Unpacked+2)

      // Round the answer by looking at the first digit
      ld a, (ix)
      cp a, 0x80
      jr c, NoRounding
      jr nz, RoundUp
      // At this point, we look at the lsb of the answer to see if we round up or down because sticky bit=0 and guard bit=1 (last byte=0x80)
      ld a, (ix+1)
      and 0x80
      jr z, NoRounding
RoundUp:
		inc (ix+1)
		jr nz, NoRounding
		inc (ix+2)
		jr nz, NoRounding
		inc (ix+3)
		jr nz, NoRounding
		inc (ix+4)
		jr nz, NoRounding
		inc (ix+5)
		jr nz, NoRounding
		inc (ix+6)
		jr nz, NoRounding
		inc (ix+7)
NoRounding:
		// Now, check for zero--zero cannot be easily normalized
		ld a, (ix+1)
		or a, (ix+2)
		or a, (ix+3)
		or a, (ix+4)
		or a, (ix+5)
		or a, (ix+6)
		or a, (ix+7)
		cp 0
		jp nz, NotZero
		pop ix
	#endasm
	if (Unpacked[10]) return dpZero; else return dpNegZero;
	#asm
NotZero:
		// Now, normalize the answer
RRLoop:
		ld a, (ix+7)
		and 0xE0
		jr z, DoneRightShifting
		// Carry is cleared because of the "and", so a zero will be shifted in
      ld hl, (ix+6) $ rr hl $ ld (ix+6), hl
      ld hl, (ix+4) $ rr hl $ ld (ix+4), hl
      ld hl, (ix+2) $ rr hl $ ld (ix+2), hl
      ld hl, (ix+0) $ rr hl $ ld (ix+0), hl

      ld hl, (ix+8)				// Adjust the exponent
		inc hl
		ld (ix+8), hl
		jr RRLoop
DoneRightShifting:
		ld a, (ix+7)
		and 0x10
		jr nz, DoneLeftShifting

      ld hl, (ix)   $ add hl, hl  $ ld (ix), hl
      ld hl, (ix+2) $ adc hl, hl  $ ld (ix+2), hl
      ld hl, (ix+4) $ adc hl, hl  $ ld (ix+4), hl
      ld hl, (ix+6) $ adc hl, hl  $ ld (ix+6), hl
      ld hl, (ix+8)				// adjust the exponent because of the shift
      dec hl
      ld (ix+8), hl
      jr DoneRightShifting
DoneLeftShifting:
		pop ix						// Lets do some range checking now in C
	#endasm

   Exponent=*((int *) (Unpacked+8));
   Sign=*((int *) Unpacked+10);

   if (Exponent > 1023) {
      if (Sign) return dpNegInfinity;
      return dpPosInfinity;
   }

   if (Exponent < -1022) {
      if (Sign) return dpNegZero;
      return dpZero;
   }

   // OK--Range checking OK after the shifts--no overflow or underflow
   // Lets combine the bits
   #asm
      push ix
      ld iy, @sp+Return+2
      add iy, sp
      ld ix, (SP+@sp+Unpacked+2)

      // IX is the source, IY is the destination
      // Adjsut the bias
      ld hl, (ix+8)
      ld de, 1023
      add hl, de
      ld (ix+8), hl

      // Copy the bytes over
      ld a, (ix+1)
      ld (iy), a
      ld a, (ix+2)
      ld (iy+1), a
      ld a, (ix+3)
      ld (iy+2), a
      ld a, (ix+4)
      ld (iy+3), a
      ld a, (ix+5)
      ld (iy+4), a
      ld a, (ix+6)
      ld (iy+5), a
      ld a, (ix+7)
      and a, 0x0F           // Remove the hidden bit and put back in the exponent
      ld b, a
      ld a, (ix+8)
      rl a
      rl a
      rl a
      rl a
      and a, 0xF0
      add a, b
      ld (iy+6), a
      ld a, (ix+8)
      rr a
      rr a
      rr a
      rr a
      and a, 0x0F
      ld b, a
      ld a, (ix+9)
      rl a
      rl a
      rl a
      rl a
      and a, 0x70
      add a, b
      or  (ix+10)  			// Put the sign bit in
      ld (iy+7), a			// Store the final bit

      pop ix
   #endasm

   return Return;
}

/* START FUNCTION DESCRIPTION ********************************************
dpDouble2Long                                        <DoublePrecision.LIB>

SYNTAX: long dpDouble2Long(_double Num);

DESCRIPTION: Converts a double precision to a long number.  This works for
             both signed and unsigned numbers.  No range checking is currently
             used.  If the number is positive, it is converted as an unsigned
             long.  If it is negative, it is converted as a signed long.
END DESCRIPTION **********************************************************/

/*** BeginHeader dpDouble2Long*/
long dpDouble2Long(_double Num);
/*** EndHeader */

long dpDouble2Long(_double Num) {
   auto char WorkArea[11];
   _dpUnpack(&Num, WorkArea);

   if (dpGT(Num, dpNegOne) && dpLT(Num, dpOne)) return 0;
   #asm
      push ix
      ld ix, WorkArea+@sp+2
      add ix, sp


loop:
      ld hl, (ix+8)		// HL stores the exponent
      ld de, -52
      add hl, de
      jr c, Done
      ld hl, (ix+8)
      inc hl
      ld (ix+8), hl
      push hl
      ld hl, (ix+6) $ rr hl $ ld (ix+6), hl
      ld hl, (ix+4) $ rr hl $ ld (ix+4), hl
      ld hl, (ix+2) $ rr hl $ ld (ix+2), hl
      ld hl, (ix  ) $ rr hl $ ld (ix  ), hl
      pop hl
      jr loop
Done:
      ld de, -53
      add hl, de
      jr nc, Equal
      pop ix
      jp ReturnNegOne;
Equal:
	   ld a, (ix+10)
	   and 0x80
	   jr z, Positive
	   // Do the two's complement
	   ld a, (ix+1)
	   cpl
	   add a, 1	// Carry is cleared from the and 0x80
	   ld (ix+1), a
	   ld a, (ix+2)
	   cpl
	   adc a, 0
	   ld (ix+2), a
	   ld a, (ix+3)
	   cpl
	   adc a, 0
	   ld (ix+3), a
	   ld a, (ix+4)
	   cpl
	   adc a, 0
	   ld (ix+4), a
Positive:		// No two-s complement is needed
   pop ix
   #endasm
   return *((long *) (WorkArea+1));
ReturnNegOne: return -1;
}

/* START FUNCTION DESCRIPTION ********************************************
dpLong2Double                                        <DoublePrecision.LIB>

SYNTAX: _double dpLong2Double(long Num)

DESCRIPTION: Converts a signed number to double precision

END DESCRIPTION **********************************************************/

/*** BeginHeader dpLong2Double*/
_double dpLong2Double(long Num);
/*** EndHeader */

_double dpLong2Double(long Num) {
   auto char WorkArea[11];
   auto _double ReturnValue;
   memset (WorkArea, 0, 11);
   if (Num<0) {
      *((long *) (WorkArea+1))=-Num;
      WorkArea[10]=128;
   } else {
      *((long *) (WorkArea+1))=Num;
	}
	*((int *) (WorkArea+8))=52;
	ReturnValue=_dpPack(WorkArea);
	return ReturnValue;
}






/* START FUNCTION DESCRIPTION ********************************************
_double dpAdd                                        <DoublePrecision.LIB>

SYNTAX: _double dpAdd(_double Num1, _double Num2);

DESCRIPTION: Adds two double precision floating point numbers
END DESCRIPTION **********************************************************/

/*** BeginHeader dpAdd*/
_double dpAdd(_double Num1, _double Num2);
/*** EndHeader */

_double dpAdd(_double Num1, _double Num2) {
   auto char WorkArea[22];
   auto _double Return;

   _dpUnpack(&Num1, WorkArea);
   _dpUnpack(&Num2, WorkArea+11);

   #asm
      push ix
      ld ix, @sp+WorkArea+2
      add ix, sp
      ld iy, @sp+WorkArea+11+2
      add iy, sp

      // Put the bias back into the exponents so I can compare to see which is larger
      ld hl, (ix+8)
      ld de, 1023
      add hl, de
      ld (ix+8), hl

      ld hl, (iy+8)
      ld de, 1023
      add hl, de
      ld (iy+8), hl


      // The first work area needs a larger absolute value than number 2

      ld a, (ix+9)
      cp (iy+9)
      jr c, Swap
      jr nz, NoSwap

      ld a, (ix+8)
      cp (iy+8)
      jr c, Swap
      jr nz, NoSwap

      ld a, (ix+7)
      cp (iy+7)
      jr c, Swap
      jr nz, NoSwap

      ld a, (ix+6)
      cp (iy+6)
      jr c, Swap
      jr nz, NoSwap

      ld a, (ix+5)
      cp (iy+5)
      jr c, Swap
      jr nz, NoSwap

      ld a, (ix+4)
      cp (iy+4)
      jr c, Swap
      jr nz, NoSwap

      ld a, (ix+3)
      cp (iy+3)
      jr c, Swap
      jr nz, NoSwap

      ld a, (ix+2)
      cp (iy+2)
      jr c, Swap
      jr nz, NoSwap

      ld a, (ix+1)
      cp (iy+1)
      jr c, Swap
      jr NoSwap

      // ix+0 and iy+0 are the rounding term--they are always zero after an unpack

Swap: ld b, 11
Swap_a:
      ld a, (iy)
      ld c, (ix)
      ld (iy), c
      ld (ix), a
      inc ix
      inc iy
      djnz Swap_a

NoSwap:
      ld ix, @sp+WorkArea+2
      add ix, sp
      ld iy, @sp+WorkArea+11+2
      add iy, sp

// At this point, the larger number is in the first position.  Lets adjust exponents to match
      ld hl, (iy+8)
      ex de, hl
      ld hl, (ix+8)
      or a
      sbc hl, de		// I know de is smaller because we swapped if the first was larger--HL now contains the number of bits to shift
      ld de, 52
      sbc hl, de
      jr c, NotVastDifference		// The larger number is so much larger than the first, no addition is necessary
   jp ReturnOriginalNumber
NotVastDifference:					// For efficiency, we align the bits first, and then the bytes separately.
											// No sense shifting more than 8 bits worth; just move bytes
	add hl, de							// Undo the damage caused by comparing to see if more than 52 bit shifts
	ld a, l
	and 0x07
	ld b, a								// Now we shift bits right for alignment
   cp 0
   jr z, DoneShiftBits
ShiftBits:
   or a									// Clear carry
   push hl                       // No savings in time after popping and pushing hl, but I found out rr (iy+d) doesn't work on older Rabbits.
   ld hl, (iy+6) $ rr hl $ ld (iy+6), hl
   ld hl, (iy+4) $ rr hl $ ld (iy+4), hl
   ld hl, (iy+2) $ rr hl $ ld (iy+2), hl
   ld hl, (iy  ) $ rr hl $ ld (iy  ), hl
   pop hl
   djnz ShiftBits
DoneShiftBits:
   ld a, l
   rr a
   rr a
   rr a
   and 0x1F
   ld b, a
   cp 0
   jr z, DoneShiftBytes

ShiftBytes:
   ld a, (iy+1)
   ld (iy), a
   ld a, (iy+2)
   ld (iy+1), a
   ld  a, (iy+3)
   ld (iy+2), a
   ld a, (iy+4)
   ld (iy+3), a
   ld a, (iy+5)
   ld (iy+4), a
   ld a, (iy+6)
   ld (iy+5), a
   ld a, (iy+7)
   ld (iy+6), a
   ld a, 0
   ld (iy+7), a
   djnz ShiftBytes
DoneShiftBytes:
   // At this point, the two mantissa's are aligned, now, see if we do addition or subtraction
   ld a, (ix+10)
   xor a, (iy+10)
   jr z, DoAdd

   // Subtraction is called for because the signs were different--carry is cleared because of the xor statement
   ld hl, (iy)
   ex de, hl
   ld hl, (ix)
   sbc hl, de
   ld (ix), hl

   ld hl, (iy+2)
   ex de, hl
   ld hl, (ix+2)
   sbc hl, de
   ld (ix+2), hl

   ld hl, (iy+4)
   ex de, hl
   ld hl, (ix+4)
   sbc hl, de
   ld (ix+4), hl

   ld hl, (iy+6)
   ex de, hl
   ld hl, (ix+6)
   sbc hl, de
   ld (ix+6), hl

   jr Finished   // The larger number contains our sign regardless of whether or not we add or subtract

DoAdd:
   ld hl, (iy)
   ex de, hl
   ld hl, (ix)
   adc hl, de
   ld (ix), hl

   ld hl, (iy+2)
   ex de, hl
   ld hl, (ix+2)
   adc hl, de
   ld (ix+2), hl

   ld hl, (iy+4)
   ex de, hl
   ld hl, (ix+4)
   adc hl, de
   ld (ix+4), hl

   ld hl, (iy+6)
   ex de, hl
   ld hl, (ix+6)
   adc hl, de
   ld (ix+6), hl
Finished:
	// I adjusted the exponent so I could compare to see which was larger in absolute value.
   // dpUnpack and dpPack use the signed exponent instead of the biased exponent.

   ld hl, (ix+8)
   ld de, -1023
   add hl, de
   ld (ix+8), hl
   pop ix
   #endasm

   // The first number in the work area now contains our number.  Now, let's repack it
   Return=_dpPack(WorkArea);
   return Return;
ReturnOriginalNumber:
   #asm
   ld hl, (ix+8)
   ld de, -1023
   add hl, de
   ld (ix+8), hl
   pop ix
   #endasm
    Return=_dpPack(WorkArea);
    return Return;

}

/* START FUNCTION DESCRIPTION ********************************************
_double dpSub                                        <DoublePrecision.LIB>

SYNTAX: _double dpSub(_double Num1, _double Num2);

DESCRIPTION: Subtracts Num2 from Num1
END DESCRIPTION **********************************************************/

/*** BeginHeader dpSub*/
_double dpSub(_double Num1, _double Num2);
/*** EndHeader */

root _double dpSub(_double Num1, _double Num2) {
   auto _double ReturnValue;

   // Change the sign of Num2
   #asm
      ld iy, @sp+Num2
      add iy, sp
      ld a, (iy+7)
      xor 0x80
      ld (iy+7), a
   #endasm

   // Due to a bug in DC, I cannot go return dpAdd(Num1, Num2)
   ReturnValue=dpAdd(Num1, Num2);
   return ReturnValue;
   // return dpAdd(Num1, Num2);
}

/* START FUNCTION DESCRIPTION ********************************************
dpNeg                                                <DoublePrecision.LIB>

SYNTAX: _double dpNeg(_double Num)

DESCRIPTION: Changes the sign of a double precision number

END DESCRIPTION **********************************************************/

/*** BeginHeader dpNeg*/
_double dpNeg(_double Num);
/*** EndHeader */

_double dpNeg(_double Num) {
   #asm
      ld iy, @sp+Num
      add iy, sp
      ld a, (iy+7)
      xor 0x80
      ld (iy+7), a
   #endasm
   return Num;
}


/* START FUNCTION DESCRIPTION ********************************************
dpMul                                                <DoublePrecision.LIB>

SYNTAX: _double dpMul(_double Num1, _double Num2);

DESCRIPTION: Multiplies two double precision numbers
END DESCRIPTION **********************************************************/

/*** BeginHeader dpMul*/
_double dpMul(_double Num1, _double Num2);
/*** EndHeader */

#asm root
   // This is a helper function used by dpMul that does an unsigned multiply and collects a sum in e', hl', and iy
_dpumul::		// Unsigned multiply--corrects the damage done by signed multiply and adds the result to some registers
   /* To correct a signed multiply to an unsigned multiply, the following is done:
      The low two bytes are always correct.
      If BC is negative, the final high two bytes (HL) need to have DE added to them
      If DE is negative, the final high two bytes (HL) need to have BC added to them.
      If both BC and DE are negative, the final high two bytes need both added to them.
   */
   push ix
   ld b, h              // For convenience, de and hl contains the items to be multiplied before calling this function, not bc-de.
   ld c, l
   ld ix, 0					// IX will contain the correction factor, calculated before multiplication
   bit 7, b
   jr z, BCPos
   add ix, de
BCPos:
   bit 7, d
   jr z, DEPos
   add ix, bc
DEPos:
   mul
   ex de, hl
   add ix, de		// Why no add ix, hl???
   ld hl, ix
   pop ix
   // IY collects the low two bytes
   // hl' collects the high two bytes byte
   // e' collects the roll-overs
   add iy, bc
   ex de, hl'
   altd adc hl, de   			// This instruction is hl'=hl+de, but overall effect of this and last instruction is hl'=hl'+hl--summing the high bytes
   ex af, af'                 // Wrong flag gets the carry result
   jr nc, NoIncrease
   exx
   inc e		// Not sure about inc e'; I think it takes e'=e+1 instead of e'=e'+1 --not much penalty here for exchanging and it is safer.
   exx
NoIncrease:
   ret
#endasm

/* Multiply is based on the following scratch-pad--each letter represents two bytes--h and l are the low or high 16 bit half
   of an unsigned multiply.

   ABCD
*  EFGH
   -------------------------------
   (A*E)h  (A*E)l   (A*F)l   (A*G)l   (A*H)l
           (A*F)h   (B*E)l   (B*F)l   (B*G)l
           (B*E)h   (A*G)h   (C*E)l   (C*F)l
                    (B*F)h   (A*H)h   (D*E)l
                    (C*E)h   (B*G)h   (B*H)h
                             (C*F)h   (C*G)h
                             (D*E)h   (D*F)h
   -------------------------------
     I       J        K        L        M

The "h" and "l" means high word and low word (16 bits).  All multiplies are handled by the
mul instruction even though it is signed multiply--the numbers are corrected.

I collect all the M terms first--and get part of my K and L terms in doing so.  Then, I rotate registers
and collect the rest of my L terms, which gets me some J and K terms.  I repeat this process until
I get all my terms.

The offset for each letter in the work area is
A--6
B--4
C--2
D--0
E--11
F--13
G--15
H--17
I--30
J--28
K--26
L--24
M--22

*/

_double dpMul(_double Num1, _double Num2) {
   auto char WorkArea[35];
   auto _double ReturnValue;

   _dpUnpack(&Num1, WorkArea);
   _dpUnpack(&Num2, WorkArea+11);

   // Do some checking for zero since I don't support de-normalized numbers
   if ((*((int *) (WorkArea+8))==-1023) || (*((int *) (WorkArea+19))==-1023)) return dpZero;
   // Two small numbers multiplied together that results in an exponent less than -1023 will be set to
   // zero in the packing section of the program

   #asm xmemok
      // iy is used for math--all accessing is done with ix
      push ix
      ld ix, @sp+WorkArea+2			// Adding two because of the push ix
      add ix, sp

      ld iy, 0
      ld hl, 0
      ld e, 0
      exx
      // Do all the high terms for M--Ignore the low results in IY
         // Multiply B*H
         ld hl, (ix+4)
         ex de, hl
         ld hl, (ix+11)
         call _dpumul
         // Multiply C*G
         ld hl, (ix+2)
         ex de, hl
         ld hl, (ix+13)
         call _dpumul
         // Multiply D*F
         ld hl, (ix)
         ex de, hl
         ld hl, (ix+15)
         call _dpumul

         // Now rotate registers so I can finish adding up terms for the "M" term
         exx
      	ld iy, hl
      	bool hl
      	ld l, e
      	ld e, h
      	exx

      	// Now, finish the M terms and some of the L terms
         // Multiply A*H
         ld hl, (ix+6)
         ex de, hl
         ld hl, (ix+11)
         call _dpumul
         // Multiply B*G
         ld hl, (ix+4)
         ex de, hl
         ld hl, (ix+13)
         call _dpumul
         // Multiply C*F
         ld hl, (ix+2)
         ex de, hl
         ld hl, (ix+15)
         call _dpumul
         // Multiply D*E
         ld hl, (ix)
         ex de, hl
         ld hl, (ix+17)
         call _dpumul

         // Store the M term and rotate registers
         ld hl, iy
         ld (ix+22), hl
         exx
         ld iy, hl
         bool hl
         ld l, e
         ld e, h
         exx

			// Finish collecting the L terms
         // Multiply A*G
         ld hl, (ix+6)
         ex de, hl
         ld hl, (ix+13)
         call _dpumul
         // Multiply B*F
         ld hl, (ix+4)
         ex de, hl
         ld hl, (ix+15)
         call _dpumul
         // Multiply C*E
         ld hl, (ix+2)
         ex de, hl
         ld hl, (ix+17)
         call _dpumul

         // Save L term, do the rotation to finish collecting the K term
         ld hl, iy
         ld (ix+24), hl
         exx
         ld iy, hl
         bool hl
         ld l, e
         ld e, h
         exx

         // Finish collecting the K terms
         // Multiply A*F
         ld hl, (ix+6)
         ex de, hl
         ld hl, (ix+15)
         call _dpumul
         // Multiply B*E
         ld hl, (ix+4)
         ex de, hl
         ld hl, (ix+17)
         call _dpumul

         // Save the K term, do rotation to finish collecting J term
         ld hl, iy
         ld (ix+26), hl
         exx
         ld iy, hl
         bool hl
         ld l, e
         ld e, h
         exx

         // Multiply A*E
         ld hl, (ix+6)
         ex de, hl
         ld hl, (ix+17)
         call _dpumul

         // Now, the J and I term are completed
         ld hl, iy
         ld (ix+28), hl     // J term
         exx
         ld (ix+30), hl     // I term

         // At this point, the I term will be between 1 and 3 because of how the bytes align for multiplication.  I will rotate left three times
         // instead of 4 and adjust the exponent by one; this way, if the multiplication went above 2 on the mantissa, I don't overshoot and then
         // have to shift right on the packing routine.  If the multiplication was less than 2 on the mantissa, the packing routine will
         // finish the last shift
         ld b, 3

         // Now, adjust the exponents--add the two together with a correction factor of four because of the way the first mantissa bit
         // starts in the middle of a byte.

         ld hl, (ix+8)  		// Unpacked signed exponent of the first number
         ex de, hl
         ld hl, (ix+19)       // Unpacked signed exponent of the second number
         add hl, de
         inc hl					// Must be modified because first bit starts in the middle of a byte
         inc hl
         inc hl
         inc hl					// Exponent is correct now for final answer
         ld (ix+32), hl			// Unpacked signed exponent of final answer

         // Put the sign byte into the unpacked number
         ld a, (ix+10)			// Sign of first number
         xor (ix+21)				// Sign of second number
         ld (ix+34), a			// Final sign
   	   pop ix
   	#endasm


   ReturnValue=_dpPack(WorkArea+24);


   return ReturnValue;
}


/* START FUNCTION DESCRIPTION ********************************************
dpDiv                                                <DoublePrecision.LIB>

SYNTAX: _double dpDiv(_double Num1, _double Num2);

DESCRIPTION: Returns a double precision number that is Num1/Num2

END DESCRIPTION **********************************************************/


/* Divide is based on bit shifting and comparint remainder to dividend

*/

/*** BeginHeader dpDiv*/
_double dpDiv(_double Num1, _double Num2);

/*** EndHeader */

_double dpDiv(_double Num1, _double Num2) {
   auto char WorkArea[33];
   auto _double ReturnValue;			// Get around a bug in DC
   auto int x;


   _dpUnpack(&Num1, WorkArea);
   _dpUnpack(&Num2, WorkArea+11);

   if (*((int *) (WorkArea+19))==-1023) {
      if (WorkArea[21] ^ WorkArea[10]) return dpNegInfinity; else return dpPosInfinity;
   }

   if (*((int *) (WorkArea+19))==2046) {
      if (WorkArea[21] ^ WorkArea[10]) return dpNegZero; else return dpZero;
   }

   // Not bothering to give NaN if both are infinity or both are zero.  Also, NaN is not propogated through the divide

   // Begin dividing
   #asm
      push ix
      ld ix, WorkArea+@sp+2
      add ix, sp
      ld b, 61
      ld a, 0
      ld (ix+22), a				// Clear out our first byte that gets the answer shifted into it.
loop:
		// Compare and subtract if less
		or a			// Clear carry
      ld hl, (ix+11)
      ex de, hl
      ld hl, (ix)
      sbc hl, de
      push hl
      ld hl, (ix+13)
      ex de, hl
      ld hl, (ix+2)
      sbc hl, de
      push hl
      ld hl, (ix+15)
      ex de, hl
      ld hl, (ix+4)
      sbc hl, de
      push hl
      ld hl, (ix+17)
      ex de, hl
      ld hl, (ix+6)
      sbc hl, de
      jr c, BitZero   	// Compare failed--remainder too small to subtract
      ld (ix+6), hl			// Store the subtraction
      pop hl
      ld (ix+4), hl
      pop hl
      ld (ix+2), hl
      pop hl
      ld (ix), hl
      scf
      jr pBitZero
BitZero:
      add sp, 6
      or a				// Clear carry flag
pBitZero:
		// Rotate the bit into our answer
		ld hl, (ix+22) $ adc hl, hl $ ld (ix+22), hl
		ld hl, (ix+24) $ adc hl, hl $ ld (ix+24), hl
		ld hl, (ix+26) $ adc hl, hl $ ld (ix+26), hl
		ld hl, (ix+28) $ adc hl, hl $ ld (ix+28), hl

		// Rotate our original number
      ld hl, (ix  ) $ add hl, hl $ ld (ix  ), hl
      ld hl, (ix+2) $ adc hl, hl $ ld (ix+2), hl
      ld hl, (ix+4) $ adc hl, hl $ ld (ix+4), hl
      ld hl, (ix+6) $ adc hl, hl $ ld (ix+6), hl

		djnz loop

		// Now, adjust our final exponent

		or a
		ld hl, (ix+19)
		ex de, hl
		ld hl, (ix+8)
		sbc hl, de
		ld (ix+30), hl

		// Put in our sign bit
		ld a, (ix+10)
		xor a, (ix+21)
		ld (ix+32), a
		pop ix
	#endasm


	ReturnValue=_dpPack(WorkArea+22);
	return ReturnValue;
}


/* START FUNCTION DESCRIPTION ********************************************
dpSqrt                                               <DoublePrecision.LIB>

SYNTAX: _double dpSqrt(_double Num)

DESCRIPTION: Returns the square root of a number

END DESCRIPTION **********************************************************/

/* The technique for finding a square root it to shift two bits at a time from
   my number into a remainder term.  I compare this remainder term to my answer
   term with a "01" appended to the end of it.  If larger, the remainder term
   gets subtracted.

   After I know whether the next bit of my answer is a 0 or 1, I add or subtract
   one to the last byte of my answer term, which is the rounding byte.  If zero, I
   subtract, and the 01 become 00.  If one, I add one, and the 01 become 10.  In
   neither case is there any worry about needing to adjust the other 7 bytes.  At
   this point, I have the answer bit in position 1, and a 0 in bit position 0.  By
   setting the carry flag and shifting, I get the answer where it belongs with a 01
   appended to the right of it.  The final answer has a 01 appended to the right in
   the rounding term, but this should have minimal impact on the accuracy.  In some
   cases, it may cause a rounding error of one bit in the last bit, but usually, it
   won't.

   Before I start, the base 2 exponent must be even, so I shift the mantissa if necessary
   to get an even base 2 exponent.  After the square root, I divide the exponent by 2.

*/

/*** BeginHeader dpSqrt*/
_double dpSqrt(_double Num);
/*** EndHeader */

_double dpSqrt(_double Num) {
   auto char WorkArea[30];
   auto _double ReturnValue;
   // WorkArea[0..10] is the original number unpacked
   // Work Area[11..18] is the remainder term
   // Work Area[19..29] is the answer term
   memset(WorkArea+11, 0, 19);	// Clear out our work area
   _dpUnpack(&Num, WorkArea);
   if (*((int *) (WorkArea+8))==-1023) return dpZero;
   if (WorkArea[10] & 0x80) return dpNaN;		// Can't take the square root of a negative number

   #asm
      push ix
      ld ix, WorkArea+@sp+2
      add ix, sp

      ld hl, (ix+8)			// Exponent--needs to be even
      bit 0, l
      jr z, ExponentEven
      dec hl
      ld (ix+8), hl

      ld hl, (ix+0) $ add hl, hl $ ld (ix+0), hl
      ld hl, (ix+2) $ adc hl, hl $ ld (ix+2), hl
		ld hl, (ix+4) $ adc hl, hl $ ld (ix+4), hl
		ld hl, (ix+6) $ adc hl, hl $ ld (ix+6), hl

ExponentEven:
   ld b, 61			// Gather 60 bits into our answer term--52 are for our number, and the extra 8 are for rounding.  The final two bits with the 01
                  // which is part of the technique for finding square root will wind up slightly affecting the answer, but it is in the rounding
                  // byte, so the damage is not worth worrying about.

Loop:
   exx
   ld b, 2   	// Shift two bits from original number into our remainder
Loop2:
   ld hl, (ix+0) $ add hl, hl $ ld (ix+0), hl
   ld hl, (ix+2) $ adc hl, hl $ ld (ix+2), hl
	ld hl, (ix+4) $ adc hl, hl $ ld (ix+4), hl
	ld hl, (ix+6) $ adc hl, hl $ ld (ix+6), hl

	ld hl, (ix+11) $ adc hl, hl $ ld (ix+11), hl
	ld hl, (ix+13) $ adc hl, hl $ ld (ix+13), hl
	ld hl, (ix+15) $ adc hl, hl $ ld (ix+15), hl
	ld hl, (ix+17) $ adc hl, hl $ ld (ix+17), hl

   djnz Loop2
   exx

   // Shift our answer by one and add one--get "01" appended to our answer
   scf // Our previous answer is zero at the lsb, the zero gets shifted over, and a one gets shiften in
	ld hl, (ix+19) $ adc hl, hl $ ld (ix+19), hl
	ld hl, (ix+21) $ adc hl, hl $ ld (ix+21), hl
	ld hl, (ix+23) $ adc hl, hl $ ld (ix+23), hl
	ld hl, (ix+25) $ adc hl, hl $ ld (ix+25), hl

   // See if we are larger
   or a		// Clear carry for the compare--using sbc to compare, and pushing the result to the stack in case we are successful
   ld hl, (ix+19)
   ex de, hl
   ld hl, (ix+11)
   sbc hl, de   // Remainder-Answer LSB
   push hl
   ld hl, (ix+21)
   ex de, hl
   ld hl, (ix+13)
   sbc hl, de
   push hl
   ld hl, (ix+23)
   ex de, hl
   ld hl, (ix+15)
   sbc hl, de
   push hl
   ld hl, (ix+25)
   ex de, hl
   ld hl, (ix+17)
   sbc hl, de
   jr c, TooSmall
   // Remainder was equal to or larger than our answer+01 term, so store the new remainder
   ld (ix+17), hl
   pop hl
   ld (ix+15), hl
   pop hl
   ld (ix+13), hl
   pop hl
   ld (ix+11), hl
   inc (ix+19)			// In the compare stage, ix+19 always is 01 on its last two bits.
                     // If successful, it is changed to 10, if unsuccessful, it is changed
                     // to 00.  There is no possibility of a wrap-around when increasing this
                     // value
	jp PastTooSmall
TooSmall:
   add sp, 6			// Subtraction failed--remainder was too small for subtraction
   dec (ix+19)
PastTooSmall:
   djnz LoopFixedRange  // Get our next bit of the square root--jump went out of range
   jp pLoopFixedRange
LoopFixedRange:
   jp Loop
pLoopFixedRange:



   // Now, put the exponent back
   ld hl, (ix+8)	// I must do a signed divide by two
   sra h
   rr  l
   ld (ix+27), hl  // Put the exponent in
   pop ix
#endasm
   ReturnValue=_dpPack(WorkArea+19);
   return ReturnValue;
}


/* START FUNCTION DESCRIPTION ********************************************
dpLog2                                               <DoublePrecision.LIB>

SYNTAX: _double dpLog2(_double Value);

DESCRIPTION: returns the base 2 logarithm
END DESCRIPTION **********************************************************/

/* I calculated the Chebyshev coefficients for a log between 1 and 1.0625.
   I found it to be the same number of terms as if I play the game of going
   (x-1)/(x+1), and since divides take a lot of time, I didn't do it.

   I have a table of 16 values and use the first four bits of the mantissa (after
   the leading 1) to determine what my scale factor is.  Since multiplying causes
   logarithms to be different by a constant, I then add the logarithm of what I
   multiplied by.

   The strings below were created on a PC using normal double precision math and
   typecasting pointers to get the internal bytes.

*/

/*** BeginHeader dpLog2*/
_double dpLog2(_double Num);
/*** EndHeader */

nodebug _double dpLog2(_double Num) {

   // ASCII text for these tables generated by a PC.
   const static long ScalingTable[32]={ 	// Using reciprocals so I can multiply instead of divide; multiply is much faster.
      0x00000000, 0x3FF00000, // 1/(1)
      0x1E1E1E1E, 0x3FEE1E1E, // 1/(1.0625)
      0x1C71C7C7, 0x3FEC71C7, // 1/(1.125)
      0xBCA1AFAF, 0x3FEAF286, // 1/(1.1875)
      0x99999999, 0x3FE99999, // 1/(1.25)
      0x18618686, 0x3FE86186, // 1/(1.3125)
      0x745D1717, 0x3FE745D1, // 1/(1.375)
      0x590B2121, 0x3FE642C8, // 1/(1.4375)
      0x55555555, 0x3FE55555, // 1/(1.5)
      0x47AE1414, 0x3FE47AE1, // 1/(1.5625)
      0x13B13B3B, 0x3FE3B13B, // 1/(1.625)
      0xBDA12F2F, 0x3FE2F684, // 1/(1.6875)
      0x92492424, 0x3FE24924, // 1/(1.75)
      0x611A7B7B, 0x3FE1A7B9, // 1/(1.8125)
      0x11111111, 0x3FE11111, // 1/(1.875)
      0x08421010, 0x3FE08421  // 1/(1.9375)
   };

   const static long LogarithmTable[32]={
      0x00000000, 0x00000000, // log2(1)
      0xFAC91313, 0x3FB663F6, // log2(1.0625)
      0x39FBD6D6, 0x3FC5C01A, // log2(1.125)
      0xB9026868, 0x3FCFBC16, // log2(1.1875)
      0x4BCD1B1B, 0x3FD49A78, // log2(1.25)
      0x891F1717, 0x3FD91BBA, // log2(1.3125)
      0xE032EAEA, 0x3FDD6753, // log2(1.375)
      0x00D63A3A, 0x3FE0C105, // log2(1.4375)
      0x473F7A7A, 0x3FE2B803, // log2(1.5)
      0x4BCD1B1B, 0x3FE49A78, // log2(1.5625)
      0x8E478888, 0x3FE66A00, // log2(1.625)
      0xD5BE7070, 0x3FE82809, // log2(1.6875)
      0xFD501010, 0x3FE9D5D9, // log2(1.75)
      0x8F553232, 0x3FEB7494, // log2(1.8125)
      0x6D260808, 0x3FED053F, // log2(1.875)
      0xB3626A6A, 0x3FEE88C6  // log2(1.9375)
   };

   const static unsigned long ChebyshevCoeff[]={
      0x87A1B0EC, 0xBFC2144A,
      0x790D956D, 0x3FF54E9D,
      0x36A6B16D, 0xC0166DC4,
      0x98209F89, 0x402BC06A,
      0x80150895, 0xC0365A9F,
      0x62E195FF, 0x40389542,
      0xF038538C, 0xC03301E7,
      0x8F3EC922, 0x402664AD,
      0xD8DEBE6A, 0xC00F04B9
   };
	/*double ChebyshevCoeff[]={		// Double precision numbers represented by the above table
      -.14124423620831495025,
      1.3316931465754706535,
     -5.6071938075295808328,
     13.875813249571154568,
    -22.353996281752718591,
     24.583044223856628331,
    -19.007445348502683854,
     11.196636654295222028,
     -3.8773076003051773387
  */

  /* It might be worth noting that for x=1 to x=1.2, all the terms are rather large numbers, yet the
     polynomial above still adds up to the correct result.
  */

   auto int Base2Exponent;
   auto char WorkArea[11];
   auto _double z;
   auto unsigned int x;
   auto unsigned int PrescaleIndex;
   auto _double ReturnValue;

   _dpUnpack(&Num, WorkArea);
   if (WorkArea[10]) {			// Can't take the logarithm of a negative number
      return dpNaN;
   }
   Base2Exponent=*((int *) (WorkArea+8));

   if (Base2Exponent==-1023) return dpNegInfinity;

   *((int *) (WorkArea+8))=0;
   PrescaleIndex=*(WorkArea+7) & 15;		// Tells us which scalar to use and what to add when we are done

   Num=_dpPack(WorkArea);						// Repack our modified number--now it is between 1 and 2
   Num=dpMul(Num, *((_double *) (ScalingTable+2*PrescaleIndex)));

   // Now, do our Chebyshev series
	for(x=0; x<9; ++x) {
	   if (x>0) ReturnValue=dpMul(ReturnValue, Num);
	   if (x>0)
	      ReturnValue=dpAdd(ReturnValue, *((_double *) (ChebyshevCoeff+2*(x))));
	   else
	      ReturnValue=*((_double *) (ChebyshevCoeff));

	}
	// Now, adjust the logarithm according to the pre-scaling and pulling out of the exponent.
	ReturnValue=dpAdd(ReturnValue, *((_double *) (LogarithmTable+PrescaleIndex*2)));
	ReturnValue=dpAdd(ReturnValue, dpLong2Double((long) Base2Exponent));
	return ReturnValue;
}

/* START FUNCTION DESCRIPTION ********************************************
dpFraction                                           <DoublePrecision.lib>

SYNTAX: _double dpFraction(_double Num);

DESCRIPTION: removes the integer part of a number

END DESCRPTION ***********************************************************/

/*** BeginHeader dpFraction*/
_double dpFraction(_double Num);
/*** EndHeader */

xmem nouseix _double dpFraction(_double Num) {
   auto char WorkArea[11];
   auto _double ReturnValue;
   _dpUnpack(&Num, WorkArea);

   #asm
      push ix
      ld ix, WorkArea+@sp+2
      add ix, sp

Loop:
      ld hl, (ix+8)    // Exponent must be negative--keep shifting and dropping off bits on the mantissa until then
      bit 7, h
      jr nz, Done
      dec hl
      ld (ix+8), hl

      ld hl, (ix)   $ add hl, hl $ ld (ix), hl
      ld hl, (ix+2) $ adc hl, hl $ ld (ix+2), hl
      ld hl, (ix+4) $ adc hl, hl $ ld (ix+4), hl
      ld hl, (ix+6) $ adc hl, hl $ ld (ix+6), hl

      jr Loop
Done:
   ld a, (ix+7)			// Strip off any shifted bits that are greater than zero
   and 0x1F
   ld (ix+7), a
   pop ix
   #endasm
   ReturnValue=_dpPack(WorkArea);
   return ReturnValue;
}




/* START FUNCTION DESCRIPTION ********************************************
dpSine                                               <DoublePrecision.LIB>

SYNTAX: _double dpSine(_double Value);

DESCRIPTION: returns the Sine of an angle in radians
END DESCRIPTION **********************************************************/

/* START FUNCTION DESCRIPTION ********************************************
dpCosine                                               <DoublePrecision.LIB>

SYNTAX: _double dpCosine(_double Value);

DESCRIPTION: returns the Cosine of an angle in radians
END DESCRIPTION **********************************************************/

/* This algorithm multiplies the number by 1/2Pi and takes the fractional
   part.  The coefficients are set up for the scaled value.

*/

/*** BeginHeader dpSine, dpCosine*/
_double dpSine(_double Num);
_double dpCosine(_double Num);
/*** EndHeader */

nodebug _double dpSine(_double Num) {
   auto _double NumSquared;
   auto _double ReturnValue;
   int x;
   const static unsigned long ChebyshevCoeff[]={ 	// Correspond to the Maple numbers at the end of the library file
      0x35CE90DE, 0x3E49293B,
      0x82A31183, 0xBE951001,
      0x22AEF9B1, 0x3ED840B6,
      0x662B21A7, 0xBF171F72,
      0xB309F5FA, 0x3F528755,
      0x1C0D661D, 0xBF88A402,
      0x0E9975EF, 0x3FBAAEC3,
      0x9DF89E98, 0xBFE6FADB,
      0x4CF1E106, 0x400E8F43,
      0xFDE7F0CD, 0xC02E3074,
      0x487EE3DD, 0x40450783,
      0xCE62BD6B, 0xC0532D2C,
      0x6775AAE1, 0x405466BC,
      0xE625BE53, 0xC044ABBC,
      0x54442D18, 0x401921FB
   };
   const static unsigned long Prescaler[]= {
      0x6DC9CD7A, 0x3FC45F30	// 1/2Pi
   };

   Num=dpFraction(dpMul(Num, *((_double *) Prescaler)));
   NumSquared=dpMul(Num, Num);

   for(x=0; x<15; ++x) {
      if (x>0) {
         ReturnValue=dpMul(ReturnValue, NumSquared);
         ReturnValue=dpAdd(ReturnValue, *((_double *) (ChebyshevCoeff+2*x)));
      } else {
         ReturnValue=*((_double *) (ChebyshevCoeff+2*x));
   	}
   }
   ReturnValue=dpMul(Num, ReturnValue);
   return ReturnValue;
}


_double dpCosine(_double Num) {
   auto _double ReturnValue;

   // DC bug won't allow a function to be a return value--it must be a variable, so I use two lines
   ReturnValue=dpSine(dpAdd(Num, dpPiDiv2));
   return ReturnValue;
}




/* START FUNCTION DESCRIPTION ********************************************
dpExp2                                               <DoublePrecision.LIB>

SYNTAX: _double dpExp2(_double Value);

DESCRIPTION: returns 2^Value
END DESCRIPTION **********************************************************/

/*** BeginHeader dpExp2*/
_double dpExp2(_double Num);
/*** EndHeader */

_double dpExp2(_double Num) {
   const static long PostFixTable[]= {
      0x00000000, 0x3FF00000, // 2^0.000000
      0x6CF9890F, 0x3FF0B558, // 2^0.062500
      0x3C7D517B, 0x3FF172B8, // 2^0.125000
      0x6E756238, 0x3FF2387A, // 2^0.187500
      0x0A31B715, 0x3FF306FE, // 2^0.250000
      0x4C123422, 0x3FF3DEA6, // 2^0.312500
      0xD5362A27, 0x3FF4BFDA, // 2^0.375000
      0xDD485429, 0x3FF5AB07, // 2^0.437500
      0x667F3BCC, 0x3FF6A09E, // 2^0.500000
      0x73EB0187, 0x3FF7A114, // 2^0.562500
      0x422AA0DB, 0x3FF8ACE5, // 2^0.625000
      0x82A3F090, 0x3FF9C491, // 2^0.687500
      0x995AD3AD, 0x3FFAE89F, // 2^0.750000
      0xDD85529C, 0x3FFC199B, // 2^0.812500
      0xDCFBA487, 0x3FFD5818, // 2^0.875000
      0xA2A490D9, 0x3FFEA4AF, // 2^0.937500
	};

   const static long ChebyshevCoeff[]={
      0x1EE84E4C, 0x3F34A1D5,
      0x83A9A572, 0x3F49779D,
      0x163FC9D8, 0x3F85C41D,
      0xA9B5144D, 0x3FABDDFA,
      0x31DC8073, 0x3FCED60B,
      0xAF148028, 0x3FE62C50,
      0x21BDA3EE, 0x3FF00025
   };


	auto int PostFixIndex;
	auto char WorkArea[11];
	auto int Exponent, x;
	auto _double ReturnValue;

   Exponent=(int) dpDouble2Long(Num);
   Num=dpFraction(Num);
	while(dpLT(Num, dpOne)) {
	   Num=dpAdd(Num, dpOne);
	   Exponent=Exponent-1;
	}
	while(dpGE(Num, dpTwo)) {
	   Num=dpSub(Num, dpOne);
	   Exponent=Exponent+1;
	}

	_dpUnpack(&Num, WorkArea);
	PostFixIndex=(WorkArea[7] & 15);
	WorkArea[7]=16;					// Set the high bit, but clear out the others
	Num=_dpPack(WorkArea);

	for(x=0; x<7; ++x) {
	   if (x>0) {
	      ReturnValue=dpMul(ReturnValue, Num);
	      ReturnValue=dpAdd(ReturnValue, *((_double *) (ChebyshevCoeff+2*x)));
	   } else {
	      ReturnValue=*((_double *) ChebyshevCoeff);
	   }
	}
	ReturnValue=dpMul(ReturnValue, *((_double *) (PostFixTable+2*PostFixIndex)));
	// Multiply by the corresponding power of two
	_dpUnpack(&ReturnValue, WorkArea);
	Exponent=*((int *) (WorkArea+8))+Exponent;
	*((int *) (WorkArea+8))=Exponent;
	ReturnValue=_dpPack(WorkArea);
	return ReturnValue;
}


/* START FUNCTION DESCRIPTION ********************************************
dpArctan                                             <DoublePrecision.LIB>

SYNTAX: _double dpArctan(_double Num);

DESCRIPTION: Returns the arctangent in radians.  For an x and y value that
             gives coordinates, use dpArcTanXY

END DESCRIPTION **********************************************************/

/*** BeginHeader dpArctan*/
_double dpArctan(_double Num);
/*** EndHeader */

_double dpArctan(_double Num) {
   auto unsigned int Inverted, Negative, x;
   auto _double ReturnValue, NumSquared;
   const static unsigned long ChebyshevCoeff[]={
      0x3A6587EB, 0xBEF4ACD6, // -0.000019717354
      0x31811CB1, 0x3F2C8B93, //  0.000217782705
      0xD6A688C8, 0xBF52B050, // -0.001140669769
      0xAEDD7F57, 0x3F6F1075, //  0.003792028284
      0x7200BD51, 0xBF8290AD, // -0.009065012971
      0x6164A2AF, 0x3F91383A, //  0.016816055483
      0xD6F43228, 0xBF9A473D, // -0.025662389989
      0xD6C9C6AC, 0x3FA160A2, //  0.033940399856
      0x3D6E9A90, 0xBFA4EA52, // -0.040850229262
      0x7E618D3B, 0x3FA7E99F, //  0.046704277208
      0x0E0273A5, 0xBFAAD185, // -0.052379758797
      0xF88BE207, 0x3FAE170D, //  0.058769642439
      0xE79FE11D, 0xBFB1107D, // -0.066657895135
      0x5E346274, 0x3FB3B129, //  0.076922021388
      0xF073B6F8, 0xBFB745CF, // -0.090909000591
      0x061C8ED2, 0x3FBC71C7, //  0.111111105911
      0x91E335D4, 0xBFC24924, // -0.142857142672
      0x9997A202, 0x3FC99999, //  0.199999999996
      0x5555534A, 0xBFD55555, // -0.333333333333
      0x00000000, 0x3FF00000  //  1.000000000000
   };



   Negative=Inverted=0;
   #asm
      ld hl, (sp+@sp+Num+6)
      bit 7, h
      jr z, Positive
      ld de, 0x8000
      add hl, de
      ld (sp+@sp+Num+6), hl
      ld hl, 1
      ld (sp+@sp+Negative), hl
Positive:
   #endasm

   if (dpGT(Num, dpOne)) {
      Inverted=1;
      Num=dpDiv(dpOne, Num);
   }
   NumSquared=dpMul(Num, Num);
   for(x=0; x<20; ++x) {
	  if (x>0) {
	     ReturnValue=dpMul(ReturnValue, NumSquared);
	     ReturnValue=dpAdd(ReturnValue, *((_double *) (ChebyshevCoeff+2*x)));
	  } else {
	     ReturnValue=*((_double *) ChebyshevCoeff);
	  }
	}

   ReturnValue=dpMul(Num, ReturnValue);

   if (Inverted) {
      ReturnValue=dpSub(dpPiDiv2, ReturnValue);
   }

   if (Negative) {
      #asm
         ld hl, (sp+ReturnValue+@sp+6)
         ld de, 0x8000
         add hl, de
         ld (sp+ReturnValue+@sp+6), hl
      #endasm
   }
   return ReturnValue;
}


/* START FUNCTION DESCRIPTION ********************************************
dpDouble2ASCII                                       <DoublePrecision.LIB>

SYNTAX: char *dpDouble2ASCII(_double Num, char *Buffer, unsigned int Digits);

END DESCRIPTION **********************************************************/

/*** BeginHeader dpDouble2ASCII*/
char *dpDouble2ASCII(_double Num, char *Buffer, unsigned int Digits);
/*** EndHeader */

char *dpDouble2ASCII(_double Num, char *Buffer, unsigned int Digits) {
   auto unsigned int Sign;

   Sign=0;
   if (dpLT(Num, dpZero)) {
      Sign=1;
      Num=dpSub(dpZero, Num);
   }
   if (Sign) {
      Buffer[0]='-';
      Buffer[1]=0;
   } else Buffer[0]=0;
   sprintf(Buffer+strlen(Buffer), "%ld.", dpDouble2Long(Num));
   Num=dpFraction(Num);

   while(strlen(Buffer)<Digits) {
      Num=dpMul(Num, dpTen);
      sprintf(Buffer+strlen(Buffer), "%d", (int) dpDouble2Long(Num));
      Num=dpFraction(Num);
   }
   return Buffer;
}


/* START FUNCTION DESCRIPTION ********************************************
dpAbs                                                <DoublePrecision.LIB>

SYNTAX: _double dpAbs(_double Num);

DESCRIPTION: returns the absolue value of a number

END DESCRIPTION **********************************************************/

/*** BeginHeader dpAbs*/
_double dpAbs(_double Num);
/*** EndHeader */

_double dpAbs(_double Num) {
   #asm
      ld hl, (sp+@sp+Num+6)
      ld de, 0x7FFF
      and hl, de
      ld (sp+@sp+Num+6), hl
   #endasm
   return Num;
}









/* START FUNCTION DESCRIPTION ********************************************
dpGT                                               <DoublePrecision.LIB>

SYNTAX: unsigned int dpGT(_double Value1, _double Value2);

DESCRIPTION: returns 1 if Value1 is greater than value 2
END DESCRIPTION **********************************************************/

/* START FUNCTION DESCRIPTION ********************************************
dpGE                                               <DoublePrecision.LIB>

SYNTAX: unsigned int dpGE(_double Value1, _double Value2);

DESCRIPTION: returns 1 if Value1 is greater than or equal to value 2
END DESCRIPTION **********************************************************/

/* START FUNCTION DESCRIPTION ********************************************
dpLT                                               <DoublePrecision.LIB>

SYNTAX: unsigned int dpGT(_double Value1, _double Value2);

DESCRIPTION: returns 1 if Value1 is less than value 2
END DESCRIPTION **********************************************************/

/* START FUNCTION DESCRIPTION ********************************************
dpGT                                               <DoublePrecision.LIB>

SYNTAX: unsigned int dpGE(_double Value1, _double Value2);

DESCRIPTION: returns 1 if Value1 is less than or equal to value 2
END DESCRIPTION **********************************************************/


/*** BeginHeader dpGT, dpLT, dpGE, dpLE*/
unsigned int dpGT(_double Value1, _double Value2);
unsigned int dpGE(_double Value1, _double Value2);
unsigned int dpLT(_double Value1, _double Value2);
unsigned int dpLE(_double Value1, _double Value2);
/*** EndHeader */

xmem nouseix unsigned int dpGT(_double Value1, _double Value2) {
   #asm
      ld hl, 0				// Return value if the two are equal
      ld de, 0				// Stack adjustment when called from other functions
_dpGT::						// entry point by the other compares
      push ix
      ld ix, Value1+@sp+2
      add ix, sp
      add ix, de
      ld iy, Value2+@sp+2
      add iy, sp
      add iy, de
      exx      			// Preserve our return value if they are equal
      ld a, (ix+7)
      bit 7, a
      jr nz, FirstNegative
      ld a, (iy+7)
      bit 7, a
      jr z, SecondPositive
      // If the first is positive, and the second is negative, then the result is a greater
      ld hl, 1
      pop ix
      lret
 SecondPositive:		// Both are positive--Compare bytes--no need to unpack
      ld b, 8
      ld de, 7
      add ix, de
      add iy, de
 loop1:
      ld a, (ix)
      cp (iy)
      jr c, Smaller1
      jr nz, Greater1
      dec ix
      dec iy
      djnz loop1
      // Equal, but not greater
      exx			// Load in the default return value
      pop ix
      lret
 Smaller1:
      ld hl, 0
      pop ix
      lret
 Greater1:
      ld hl, 1
      pop ix
      lret
 FirstNegative:
      ld a, (iy+7)
      bit 7, a
      jr nz, SecondNegative
      // If the first is negative and the second is positive, it is less
      ld hl, 0
      pop ix
      lret
SecondNegative:
      ld b, 8
      ld de, 7
      add ix, de
      add iy, de
Loop2:
      ld a, (ix)
      cp (iy)
      jr c, Smaller2
      jr nz, Greater2
      dec ix
      dec iy
      djnz Loop2
      exx			// Values are equal--return the equal value
      pop ix
      lret
Smaller2:		// Value1 is smaller in absolute value than value2
      ld hl, 1 // Therefore, it is larger
      pop ix
      lret
Greater2:
      ld hl, 0
      pop ix
      lret
   #endasm
}

xmem nouseix unsigned int dpGE(_double Value1, _double Value2) {
   #asm
      ld hl, 1
      ld de, 0
      ljp _dpGT
   #endasm
}

xmem nouseix unsigned int dpLT(_double Value1, _double Value2) {
	#asm
      ld hl, 1		// If equal, return zero, but initialized with one since I invert the result
      ld de, 3
      lcall _dpGT
      // Invert the greater than result
      dec hl
      bool hl
      lret
   #endasm
}

xmem nouseix unsigned int dpLE(_double Value1, _double Value2) {
	#asm
      ld hl, 0		// If equal, return zero, but initialized with one since I invert the result
      ld de, 3
      lcall _dpGT
      // Invert the greater than result
      dec hl
      bool hl
      lret
   #endasm
}








/*************************************************************
 *      LINEAR REGRESSION FUNCTIONS                          *
 *************************************************************/



/* START FUNCTION DESCRIPTION ********************************************
lrClear                                              <DoublePrecision.LIB>

SYNTAX: void lrClear(lrData Data)

DESCRIPTION: Clears out linear regression data
END DESCRIPTION **********************************************************/

/*** BeginHeader lrClear*/
typedef struct {
   _double SumX,
           SumY,
           SumXY,
           SumXX,
           SumYY;
   long Terms;
} lrData[1];
void lrClear(lrData Data);
/*** EndHeader */

void lrClear(lrData Data) {
   Data->SumX=dpZero;
   Data->SumY=dpZero;
   Data->SumXY=dpZero;
   Data->SumXX=dpZero;
   Data->SumYY=dpZero;
   Data->Terms=0;
}

/* START FUNCTION DESCRIPTION ********************************************
lrAddTerm                                            <DoublePrecision.LIB>

SYNTAX: void lrAddTerm(lrData Data, _double x, _double y)

DESCRIPTION: Adds a term to the linear regression data stored in the structure
             lrData.

END DESCRIPTION **********************************************************/

/*** BeginHeader lrAddTerm*/
void lrAddTerm(lrData Data, _double x, _double y);
/*** EndHeader */

void lrAddTerm(lrData Data, _double X, _double Y) {
   auto _double XX, XY, YY;
   XX=dpMul(X,X);
   YY=dpMul(Y,Y);
   XY=dpMul(X,Y);

   Data->SumX=dpAdd(Data->SumX, X);
   Data->SumY=dpAdd(Data->SumY, Y);
   Data->SumXX=dpAdd(Data->SumXX, XX);
   Data->SumYY=dpAdd(Data->SumYY, YY);
   Data->SumXY=dpAdd(Data->SumXY, XY);
   ++Data->Terms;
}

/* START FUNCTION DESCRIPTION ********************************************
lrSlope                                              <DoublePrecision.LIB>

SYNTAX: _double lrSlope(lrData Data)

DESCRIPTION: Returns the slope of the linear regression data
END DESCRIPTION **********************************************************/

/*** BeginHeader lrSlope*/
_double lrSlope(lrData Data);
/*** EndHeader */
_double lrSlope(lrData Data) {
   auto _double X, Y, XX, XY, YY, Terms, Return;
   Terms=dpLong2Double(Data->Terms);
   X=Data->SumX;
   Y=Data->SumY;
   XY=Data->SumXY;
   XX=Data->SumXX;
   YY=Data->SumYY;

   Return=dpDiv(dpSub(dpMul(Terms,XY), dpMul(X,Y)), dpSub(dpMul(Terms,XX), dpMul(X,X))); //Return=(Terms*XY-X*Y)/(Terms*XX-X*X)
   return Return;
}

/* START FUNCTION DESCRIPTION ********************************************
lrIntercept                                          <DoublePrecision.LIB>

SYNTAX: _double lrIntercept(lrData Data)

DESCRIPTION: returns the zero intercept of the linear regression data

END DESCRIPTION **********************************************************/
/*** BeginHeader lrIntercept*/
_double lrIntercept(lrData Data);
/*** EndHeader */

_double lrIntercept(lrData Data) {
   auto _double X, Y, XX, XY, YY, Terms, Return;
   Terms=dpLong2Double(Data->Terms);
   X=Data->SumX;
   Y=Data->SumY;
   XY=Data->SumXY;
   XX=Data->SumXX;
   YY=Data->SumYY;

   Return=dpDiv(dpSub(Y, dpMul(lrSlope(Data),X)), Terms); //Return=(Y-lrSlope(Data)*X)/Terms
   return Return;
}

/* START FUNCTION DESCRIPTION ********************************************
lrCorrelation                                        <DoublePrecision.LIB>

SYNTAX: _double lrCorrelation(lrData Data)

DESCRIPTION: returns the correlation of the linear regression data

END DESCRIPTION **********************************************************/


/*** BeginHeader lrCorrelation*/
_double lrCorrelation(lrData Data);
/*** EndHeader */

_double lrCorrelation(lrData Data) {
   auto _double X, Y, XX, XY, YY, Terms, Return;
   Terms=dpLong2Double(Data->Terms);
   X=Data->SumX;
   Y=Data->SumY;
   XY=Data->SumXY;
   XX=Data->SumXX;
   YY=Data->SumYY;

   Return=dpDiv(dpSub(dpMul(Terms,XY), dpMul(X,Y)), dpSqrt(dpMul(dpSub(dpMul(Terms,XX), dpMul(X,X)),dpSub(dpMul(Terms,YY), dpMul(Y,Y))))); //Return=(Terms*XY-X*Y)/dpSqrt((Terms*XX-X*X)*(Terms*YY-Y*Y))
	return Return;
}














































/************************************************************************************
 *                 CALCULATING THE POWER SERIES COEFFICIENTS                        *
 ************************************************************************************

 Rather than use the text-book Taylor series, I used Chebyshev coefficients.  The program
 that created these coefficients is Maple(r) by Waterloo Maple Software.

 With Taylor polynomials, you don't get as fast of convergence.  What Chebyshev does is
 finds the lowest polynomial and the coefficients for the accuracy specified.  With
 Chebyshev, if you wish additional accuracy, all your former terms will change, since it
 simply finds the best polynomial for the given range.  With Taylor, once a term is found,
 if you want more accuracy, you get additional terms, but former terms never change.
 Chebyshev approximates Taylor, and the terms look similar, but the numbers diverge away.
 This can actually cause very accurate series when the last term in the series isn't a
 very small number.  Atan(x) for x near 1 is accurate with these polynomials,
 but the last term isn't a very small term.

 The faster a series converges, the closer the Chebyshev polynomial will be to the Taylor
 polynomial.

 Because Chebyshev finds the best polynomial for the range specified, the error is spread out
 over the interval, unlike Taylor, which is very accurate near the center point and
 gets less accurate as you move away.

 The following is the Maple script used to get the coefficients used in this program.  Digits
 is its internal precision.  Precision tells what error I will will accept, and it finds a
 polynomial of the lowest degree with the most optimized coefficients.  These numbers were
 fed into a C program that typecast a floating point number into a long pointer, and the
 IEEE 754 internal bytes were obtained for putting into the series.

 In many cases, such as xP(x^2)=F(x), I change this to
 x'=x^2, so P(x')=F(sqrt(x'))/sqrt(x').



********************************************************************************************
*                                Maple Script                                              *
********************************************************************************************

> with(orthopoly,T);
                                                                             [T]





> # Set the internal number of digits Maple uses for its calculations.


> Digits:=20;
                                                                        Digits := 20





> # Double precision numbers are not accurate to more than 16 decimal places.  Higher
> # precision will only result in larger polynomials.


> Precision:=1E-16;
                                                                                      -15

                                                                    Precision := .1*10





> #I want base 2 logarithm coefficients.  The range is from 1 to 1.0625 because there were too many
> #terms to let it go from 1 to 2 (21 terms).  I prescale my log by looking at 4 bits after the leading 1 in the
> #mantissa and dividing, so x is always from 1 to 1.0625.  I subtract out the base 2 integer exponent
> #and set it to zero before the pre-scaling.


> chebyshev(log(x)/log(2),x=1..1.0625, Precision);
                                                                                                                                         -5

         .044062808042958451196 T(0, %1) + .043728072431811485997 T(1, %1) - .00033134936081563049169 T(2, %1) + .33477319505796353438*10   T(3, %1)



                                        -7                                    -9                                    -11

              - .38051145876704042175*10   T(4, %1) + .46133194219192024242*10   T(5, %1) - .58262360869539348677*10    T(6, %1)



                                        -13                                    -14

              + .75682782088220989813*10    T(7, %1) - .10036006600580190469*10    T(8, %1)



%1 :=                                                32.000000000000000000 x - 33.000000000000000000





> sort(expand(evalf(")));
                                     8                          7                          6                          5                          4

            - .14124423620831495025 x  + 1.3316931465754706535 x  - 5.6071938075295808328 x  + 13.875813249571154568 x  - 22.353996281752718591 x



                                         3                          2

                + 24.583044223856628331 x  - 19.007445348502683854 x  + 11.196636654295222028 x - 3.8773076003051773387





> # I set the sine up so that each integer repeats itself.  This way, I pre-scale by multiplying by 1/(2*Pi).
> # Then, I remove the integer portion. I know that sine is an odd function, so it only has odd terms in the
> # polynomial.  I can use the following equation
>
> #  yP(y^2)~=sin(y*(2*Pi))==>P(x)=sin(sqrt(x)*(2*Pi))/sqrt(x)
>
> # I looked at using only one quadrant for a smaller series, but the terms saved was only two--I figured
> # I would spend longer playing around to get my number into the right quadrant than using a series
> # that was accurate over the full circle.


> chebyshev(sin(sqrt(x)*2*Pi)/sqrt(x), x=0.0001..1, Precision);
      .75819711501018419695 T(0, %1) - 2.3661610638553388245 T(1, %1) + 2.2503991980669377589 T(2, %1) - .75977876807345275504 T(3, %1)



           + .12997425031714743742 T(4, %1) - .013537490490405355746 T(5, %1) + .00095353294265244545502 T(6, %1) - .000048596967227790831170 T(7, %1)



                                     -5                                    -7                                    -8

           + .18787303197156873773*10   T(8, %1) - .57050998601921339424*10   T(9, %1) + .13979486477187350327*10   T(10, %1)



                                     -10                                     -12                                     -14

           - .28238574452578589001*10    T(11, %1) + .47851551783183950327*10    T(12, %1) - .69001593660568356270*10    T(13, %1)



                                     -16

           + .87172828433124119893*10    T(14, %1)



%1 :=                                                2.0002000200020002000 x - 1.0002000200020002000





> sort(expand(evalf(")));
                               -7  14                           -6  13                           -5  12                              11

       .11716531461894385991*10   x   - .31385605104804342097*10   x   + .57823131482379254112*10   x   - .000088206632010151731741 x



                                       10                           9                          8                          7                          6

            + .0011308991344373119193 x   - .012031570893372972497 x  + .10422915560180688501 x  - .71812229970687993438 x  + 3.8199525843921290750 x



                                     5                          4                          3                          2

            - 15.094642576754631296 x  + 42.058693944891026405 x  - 76.705859753061003124 x  + 81.605249276075042778 x  - 41.341702240399760100 x



            + 6.2831853071795864765





> #Since cos is an even function, all polynomial terms will be even, so I factor them out.  Again, I multiply by 2*Pi


> chebyshev(cos(sqrt(x)*2*Pi), x=0..1, Precision);
    .22027690853993446229 T(0, 2 x - 1) + .57576073503193798883 T(1, 2 x - 1) + .63136093387883497818 T(2, 2 x - 1) - .55537681056570965079 T(3, 2 x - 1)



         + .14659065140094023092 T(4, 2 x - 1) - .020276913022748529369 T(5, 2 x - 1) + .0017667326590583069132 T(6, 2 x - 1)



                                                                            -5                                         -6

         - .00010684737510106378972 T(7, 2 x - 1) + .47690365676936170055*10   T(8, 2 x - 1) - .16396846631608543990*10   T(9, 2 x - 1)



                                   -8                                          -10                                          -11

         + .44828140715884525301*10   T(10, 2 x - 1) - .99883484104257135317*10    T(11, 2 x - 1) + .18498688434884423571*10    T(12, 2 x - 1)



                                   -13                                          -15

         - .28940176458459212375*10    T(13, 2 x - 1) + .38764193739202475655*10    T(14, 2 x - 1)





> sort(expand(evalf(")));
                        -7  14                           -5  13                              12                             11                            10

.52028420114275808145*10   x   - .13352701238433011234*10   x   + .000022967908959219586799 x   - .00032281883257556101948 x   + .0037796768649360867355 x



                               9                          8                          7                          6                          5

     - .036382738187230035438 x  + .28200591983357339914 x  - 1.7143906945912373267 x  + 7.9035363673618583406 x  - 26.426256782723570823 x



                              4                          3                          2

     + 60.244641371806775213 x  - 85.456817206689207974 x  + 64.939394022668138390 x  - 19.739208802178715189 x + .9999999999999999954





> # I use the identity 2^(x+y)=(2^x)*(2^y)
> # I use the first four bits after the leading one in the mantissa to determine what
> # to multiply by after I get the exponent.  I don't actually call subtract to get
> # a value between 1 and 1.0625; I take a short-cut and zero out the bits.
> # By allowing a range of 1..2, I had a polynomial of 12 terms.  This subtracting
> # and multiplying the final answer got the polynomial down to 7 terms.


> chebyshev(2^x, x=1..1.0625, Precision);
                                                                                                                                        -6

         2.0440340375244147060 T(0, %1) + .044272916926218518164 T(1, %1) + .00023974255958107940765 T(2, %1) + .86549611930512083090*10   T(3, %1)



                                        -8                                    -11                                    -14

              + .23434088924408083624*10   T(4, %1) + .50760028615896574295*10    T(5, %1) + .91625188388888888890*10    T(6, %1)



%1 :=                                                32.000000000000000000 x - 33.000000000000000000





> sort(expand(evalf(")));
                                   6                            5                           4                           3                          2

         .00031482175009609336605 x  + .0007771987068966714515 x  + .010627963296404738794 x  + .054427941528537891155 x  + .24090709623942848069 x



              + .69290956683471892223 x + 1.0000354116439172165





> # Here is a case where Chebyshev works much better than Taylor.  The series for Arctan is
> # x-(1/3)x^3+(1/5)x^5+...
> # I do the standard factoring.  I considered using the identity:
> # Arctan(x)=Pi/4+ArcTan((x-1)/(x+1)), but the terms saved would not justify a time consuming divide.
> # Here is where Chebyshev does something Taylor cannot do.  The polynomial below is accurate even near
> # 1 (Arctan(0.98)).  However, the 19'th term at 0.98 is 0.000013061, yet the result is accurate out to
> # 15 decimal places.
>
>


> chebyshev(arctan(sqrt(x))/sqrt(x), x=0.001..1, Precision);
  .88124043464400624075 T(0, %1) - .10573248541422154153 T(1, %1) + .011103519015153850054 T(2, %1) - .0013752591718135288773 T(3, %1)



                                                                                                          -5                                    -6

       + .00018468510895768917420 T(4, %1) - .000026029232265311387590 T(5, %1) + .37885887273054862464*10   T(6, %1) - .56428255679940414050*10   T(7, %1)



                                 -7                                    -7                                    -8

       + .85512717220982371843*10   T(8, %1) - .13134694250150425897*10   T(9, %1) + .20393946591033011328*10   T(10, %1)



                                 -9                                     -10                                     -11

       - .31946815817942552438*10   T(11, %1) + .50415336835912892327*10    T(12, %1) - .80060167279613476637*10    T(13, %1)



                                 -11                                     -12                                     -13

       + .12782136773278094319*10    T(14, %1) - .20502872672821036728*10    T(15, %1) + .33021667689201215719*10    T(16, %1)



                                 -14                                     -15                                     -15

       - .53376387139551905131*10    T(17, %1) + .86555051111111111113*10    T(18, %1) - .14076123338786369845*10    T(19, %1)



%1 :=                                                2.0020020020020020020 x - 1.0020020020020020020





> sort(expand(evalf(")));
                                19                             18                            17                            16                            15

   - .000019717353688782009171 x   + .00021778270525116750673 x   - .0011406697691219036943 x   + .0037920282838256701049 x   - .0090650129714890138200 x



                                 14                           13                           12                           11                           10

       + .016816055483249212083 x   - .025662389988655360434 x   + .033940399855862806407 x   - .040850229262379690274 x   + .046704277207732813187 x



                                 9                           8                           7                           6                           5

       - .052379758796838242181 x  + .058769642439020988591 x  - .066657895134885033705 x  + .076922021388222298629 x  - .090909000591377407488 x



                                4                          3                          2

       + .11111110591132991243 x  - .14285714267172854413 x  + .19999999999642174865 x  - .33333333333330429689 x + .99999999999999994693









*/



















